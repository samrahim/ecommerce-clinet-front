import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Cursor: { input: any; output: any; }
  Time: { input: any; output: any; }
  Upload: { input: any; output: any; }
};

export type AddProductImages = {
  __typename?: 'AddProductImages';
  added: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  origin: Scalars['String']['output'];
};

export type Attributes = Node & {
  __typename?: 'Attributes';
  createdAt?: Maybe<Scalars['Time']['output']>;
  data?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  image?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  price?: Maybe<Scalars['Float']['output']>;
  updatedAt?: Maybe<Scalars['Time']['output']>;
  variant?: Maybe<Variant>;
};

/** A connection to a list of items. */
export type AttributesConnection = {
  __typename?: 'AttributesConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AttributesEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type AttributesEdge = {
  __typename?: 'AttributesEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Attributes>;
};

/** Ordering options for Attributes connections */
export type AttributesOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order AttributesSlice. */
  field: AttributesOrderField;
};

/** Properties by which Attributes connections can be ordered. */
export enum AttributesOrderField {
  CreatedAt = 'CREATED_AT',
  Data = 'DATA',
  Name = 'NAME',
  Price = 'PRICE',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * AttributesWhereInput is used for filtering Attributes objects.
 * Input was generated by ent.
 */
export type AttributesWhereInput = {
  and?: InputMaybe<Array<AttributesWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** data field predicates */
  data?: InputMaybe<Scalars['String']['input']>;
  dataContains?: InputMaybe<Scalars['String']['input']>;
  dataContainsFold?: InputMaybe<Scalars['String']['input']>;
  dataEqualFold?: InputMaybe<Scalars['String']['input']>;
  dataGT?: InputMaybe<Scalars['String']['input']>;
  dataGTE?: InputMaybe<Scalars['String']['input']>;
  dataHasPrefix?: InputMaybe<Scalars['String']['input']>;
  dataHasSuffix?: InputMaybe<Scalars['String']['input']>;
  dataIn?: InputMaybe<Array<Scalars['String']['input']>>;
  dataIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dataLT?: InputMaybe<Scalars['String']['input']>;
  dataLTE?: InputMaybe<Scalars['String']['input']>;
  dataNEQ?: InputMaybe<Scalars['String']['input']>;
  dataNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  dataNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** variant edge predicates */
  hasVariant?: InputMaybe<Scalars['Boolean']['input']>;
  hasVariantWith?: InputMaybe<Array<VariantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** image field predicates */
  image?: InputMaybe<Scalars['String']['input']>;
  imageContains?: InputMaybe<Scalars['String']['input']>;
  imageContainsFold?: InputMaybe<Scalars['String']['input']>;
  imageEqualFold?: InputMaybe<Scalars['String']['input']>;
  imageGT?: InputMaybe<Scalars['String']['input']>;
  imageGTE?: InputMaybe<Scalars['String']['input']>;
  imageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  imageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  imageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  imageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  imageLT?: InputMaybe<Scalars['String']['input']>;
  imageLTE?: InputMaybe<Scalars['String']['input']>;
  imageNEQ?: InputMaybe<Scalars['String']['input']>;
  imageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  imageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<AttributesWhereInput>;
  or?: InputMaybe<Array<AttributesWhereInput>>;
  /** price field predicates */
  price?: InputMaybe<Scalars['Float']['input']>;
  priceGT?: InputMaybe<Scalars['Float']['input']>;
  priceGTE?: InputMaybe<Scalars['Float']['input']>;
  priceIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  priceIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  priceLT?: InputMaybe<Scalars['Float']['input']>;
  priceLTE?: InputMaybe<Scalars['Float']['input']>;
  priceNEQ?: InputMaybe<Scalars['Float']['input']>;
  priceNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  priceNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Book = Node & {
  __typename?: 'Book';
  amount: Scalars['Float']['output'];
  cart: Cart;
  cookie?: Maybe<Scalars['String']['output']>;
  coupon?: Maybe<Coupon>;
  createdAt?: Maybe<Scalars['Time']['output']>;
  customer?: Maybe<User>;
  id: Scalars['ID']['output'];
  image?: Maybe<Scalars['String']['output']>;
  refund?: Maybe<Refund>;
  shippingAddress: Scalars['String']['output'];
  status?: Maybe<Array<BookStatus>>;
  trackingNumber?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['Time']['output']>;
};

/** A connection to a list of items. */
export type BookConnection = {
  __typename?: 'BookConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BookEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BookEdge = {
  __typename?: 'BookEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Book>;
};

/** Ordering options for Book connections */
export type BookOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Books. */
  field: BookOrderField;
};

/** Properties by which Book connections can be ordered. */
export enum BookOrderField {
  Cookie = 'COOKIE',
  CreatedAt = 'CREATED_AT',
  ShippingAddress = 'SHIPPING_ADDRESS',
  UpdatedAt = 'UPDATED_AT'
}

export type BookStatus = Node & {
  __typename?: 'BookStatus';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  order?: Maybe<Book>;
  state: BookStatusState;
};

/** A connection to a list of items. */
export type BookStatusConnection = {
  __typename?: 'BookStatusConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BookStatusEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BookStatusEdge = {
  __typename?: 'BookStatusEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BookStatus>;
};

/** BookStatusState is enum for the field state */
export enum BookStatusState {
  Cancelled = 'cancelled',
  Completed = 'completed',
  Pending = 'pending',
  Retured = 'retured',
  Shipped = 'shipped'
}

/**
 * BookStatusWhereInput is used for filtering BookStatus objects.
 * Input was generated by ent.
 */
export type BookStatusWhereInput = {
  and?: InputMaybe<Array<BookStatusWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** order edge predicates */
  hasOrder?: InputMaybe<Scalars['Boolean']['input']>;
  hasOrderWith?: InputMaybe<Array<BookWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<BookStatusWhereInput>;
  or?: InputMaybe<Array<BookStatusWhereInput>>;
  /** state field predicates */
  state?: InputMaybe<BookStatusState>;
  stateIn?: InputMaybe<Array<BookStatusState>>;
  stateNEQ?: InputMaybe<BookStatusState>;
  stateNotIn?: InputMaybe<Array<BookStatusState>>;
};

/**
 * BookWhereInput is used for filtering Book objects.
 * Input was generated by ent.
 */
export type BookWhereInput = {
  /** amount field predicates */
  amount?: InputMaybe<Scalars['Float']['input']>;
  amountGT?: InputMaybe<Scalars['Float']['input']>;
  amountGTE?: InputMaybe<Scalars['Float']['input']>;
  amountIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  amountLT?: InputMaybe<Scalars['Float']['input']>;
  amountLTE?: InputMaybe<Scalars['Float']['input']>;
  amountNEQ?: InputMaybe<Scalars['Float']['input']>;
  amountNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  and?: InputMaybe<Array<BookWhereInput>>;
  /** cookie field predicates */
  cookie?: InputMaybe<Scalars['String']['input']>;
  cookieContains?: InputMaybe<Scalars['String']['input']>;
  cookieContainsFold?: InputMaybe<Scalars['String']['input']>;
  cookieEqualFold?: InputMaybe<Scalars['String']['input']>;
  cookieGT?: InputMaybe<Scalars['String']['input']>;
  cookieGTE?: InputMaybe<Scalars['String']['input']>;
  cookieHasPrefix?: InputMaybe<Scalars['String']['input']>;
  cookieHasSuffix?: InputMaybe<Scalars['String']['input']>;
  cookieIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cookieIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cookieLT?: InputMaybe<Scalars['String']['input']>;
  cookieLTE?: InputMaybe<Scalars['String']['input']>;
  cookieNEQ?: InputMaybe<Scalars['String']['input']>;
  cookieNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cookieNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** cart edge predicates */
  hasCart?: InputMaybe<Scalars['Boolean']['input']>;
  hasCartWith?: InputMaybe<Array<CartWhereInput>>;
  /** coupon edge predicates */
  hasCoupon?: InputMaybe<Scalars['Boolean']['input']>;
  hasCouponWith?: InputMaybe<Array<CouponWhereInput>>;
  /** customer edge predicates */
  hasCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  hasCustomerWith?: InputMaybe<Array<UserWhereInput>>;
  /** refund edge predicates */
  hasRefund?: InputMaybe<Scalars['Boolean']['input']>;
  hasRefundWith?: InputMaybe<Array<RefundWhereInput>>;
  /** status edge predicates */
  hasStatus?: InputMaybe<Scalars['Boolean']['input']>;
  hasStatusWith?: InputMaybe<Array<BookStatusWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** image field predicates */
  image?: InputMaybe<Scalars['String']['input']>;
  imageContains?: InputMaybe<Scalars['String']['input']>;
  imageContainsFold?: InputMaybe<Scalars['String']['input']>;
  imageEqualFold?: InputMaybe<Scalars['String']['input']>;
  imageGT?: InputMaybe<Scalars['String']['input']>;
  imageGTE?: InputMaybe<Scalars['String']['input']>;
  imageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  imageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  imageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  imageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  imageLT?: InputMaybe<Scalars['String']['input']>;
  imageLTE?: InputMaybe<Scalars['String']['input']>;
  imageNEQ?: InputMaybe<Scalars['String']['input']>;
  imageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  imageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<BookWhereInput>;
  or?: InputMaybe<Array<BookWhereInput>>;
  /** shipping_address field predicates */
  shippingAddress?: InputMaybe<Scalars['String']['input']>;
  shippingAddressContains?: InputMaybe<Scalars['String']['input']>;
  shippingAddressContainsFold?: InputMaybe<Scalars['String']['input']>;
  shippingAddressEqualFold?: InputMaybe<Scalars['String']['input']>;
  shippingAddressGT?: InputMaybe<Scalars['String']['input']>;
  shippingAddressGTE?: InputMaybe<Scalars['String']['input']>;
  shippingAddressHasPrefix?: InputMaybe<Scalars['String']['input']>;
  shippingAddressHasSuffix?: InputMaybe<Scalars['String']['input']>;
  shippingAddressIn?: InputMaybe<Array<Scalars['String']['input']>>;
  shippingAddressLT?: InputMaybe<Scalars['String']['input']>;
  shippingAddressLTE?: InputMaybe<Scalars['String']['input']>;
  shippingAddressNEQ?: InputMaybe<Scalars['String']['input']>;
  shippingAddressNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** tracking_number field predicates */
  trackingNumber?: InputMaybe<Scalars['String']['input']>;
  trackingNumberContains?: InputMaybe<Scalars['String']['input']>;
  trackingNumberContainsFold?: InputMaybe<Scalars['String']['input']>;
  trackingNumberEqualFold?: InputMaybe<Scalars['String']['input']>;
  trackingNumberGT?: InputMaybe<Scalars['String']['input']>;
  trackingNumberGTE?: InputMaybe<Scalars['String']['input']>;
  trackingNumberHasPrefix?: InputMaybe<Scalars['String']['input']>;
  trackingNumberHasSuffix?: InputMaybe<Scalars['String']['input']>;
  trackingNumberIn?: InputMaybe<Array<Scalars['String']['input']>>;
  trackingNumberIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  trackingNumberLT?: InputMaybe<Scalars['String']['input']>;
  trackingNumberLTE?: InputMaybe<Scalars['String']['input']>;
  trackingNumberNEQ?: InputMaybe<Scalars['String']['input']>;
  trackingNumberNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  trackingNumberNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Cart = Node & {
  __typename?: 'Cart';
  createdAt: Scalars['Time']['output'];
  customer?: Maybe<User>;
  id: Scalars['ID']['output'];
  items?: Maybe<Array<CartItem>>;
  order?: Maybe<Book>;
  totalPrice: Scalars['Float']['output'];
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type CartConnection = {
  __typename?: 'CartConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CartEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CartEdge = {
  __typename?: 'CartEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Cart>;
};

export type CartItem = Node & {
  __typename?: 'CartItem';
  addedAt: Scalars['Time']['output'];
  cart?: Maybe<Cart>;
  id: Scalars['ID']['output'];
  product?: Maybe<Product>;
  quantity: Scalars['Int']['output'];
};

/** A connection to a list of items. */
export type CartItemConnection = {
  __typename?: 'CartItemConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CartItemEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CartItemEdge = {
  __typename?: 'CartItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CartItem>;
};

/** Ordering options for CartItem connections */
export type CartItemOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order CartItems. */
  field: CartItemOrderField;
};

/** Properties by which CartItem connections can be ordered. */
export enum CartItemOrderField {
  AddedAt = 'ADDED_AT',
  Quantity = 'QUANTITY'
}

/**
 * CartItemWhereInput is used for filtering CartItem objects.
 * Input was generated by ent.
 */
export type CartItemWhereInput = {
  /** added_at field predicates */
  addedAt?: InputMaybe<Scalars['Time']['input']>;
  addedAtGT?: InputMaybe<Scalars['Time']['input']>;
  addedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  addedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  addedAtLT?: InputMaybe<Scalars['Time']['input']>;
  addedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  addedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  addedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  and?: InputMaybe<Array<CartItemWhereInput>>;
  /** cart edge predicates */
  hasCart?: InputMaybe<Scalars['Boolean']['input']>;
  hasCartWith?: InputMaybe<Array<CartWhereInput>>;
  /** product edge predicates */
  hasProduct?: InputMaybe<Scalars['Boolean']['input']>;
  hasProductWith?: InputMaybe<Array<ProductWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CartItemWhereInput>;
  or?: InputMaybe<Array<CartItemWhereInput>>;
  /** quantity field predicates */
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quantityGT?: InputMaybe<Scalars['Int']['input']>;
  quantityGTE?: InputMaybe<Scalars['Int']['input']>;
  quantityIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  quantityLT?: InputMaybe<Scalars['Int']['input']>;
  quantityLTE?: InputMaybe<Scalars['Int']['input']>;
  quantityNEQ?: InputMaybe<Scalars['Int']['input']>;
  quantityNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Ordering options for Cart connections */
export type CartOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Carts. */
  field: CartOrderField;
};

/** Properties by which Cart connections can be ordered. */
export enum CartOrderField {
  CreatedAt = 'CREATED_AT',
  TotalPrice = 'TOTAL_PRICE',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * CartWhereInput is used for filtering Cart objects.
 * Input was generated by ent.
 */
export type CartWhereInput = {
  and?: InputMaybe<Array<CartWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** customer edge predicates */
  hasCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  hasCustomerWith?: InputMaybe<Array<UserWhereInput>>;
  /** items edge predicates */
  hasItems?: InputMaybe<Scalars['Boolean']['input']>;
  hasItemsWith?: InputMaybe<Array<CartItemWhereInput>>;
  /** order edge predicates */
  hasOrder?: InputMaybe<Scalars['Boolean']['input']>;
  hasOrderWith?: InputMaybe<Array<BookWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CartWhereInput>;
  or?: InputMaybe<Array<CartWhereInput>>;
  /** total_price field predicates */
  totalPrice?: InputMaybe<Scalars['Float']['input']>;
  totalPriceGT?: InputMaybe<Scalars['Float']['input']>;
  totalPriceGTE?: InputMaybe<Scalars['Float']['input']>;
  totalPriceIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  totalPriceLT?: InputMaybe<Scalars['Float']['input']>;
  totalPriceLTE?: InputMaybe<Scalars['Float']['input']>;
  totalPriceNEQ?: InputMaybe<Scalars['Float']['input']>;
  totalPriceNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Category = Node & {
  __typename?: 'Category';
  children?: Maybe<Array<Category>>;
  createdAt?: Maybe<Scalars['Time']['output']>;
  createdby?: Maybe<User>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  parent?: Maybe<Category>;
  products?: Maybe<Array<Product>>;
  updatedAt?: Maybe<Scalars['Time']['output']>;
};

/** A connection to a list of items. */
export type CategoryConnection = {
  __typename?: 'CategoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CategoryEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CategoryEdge = {
  __typename?: 'CategoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Category>;
};

/** Ordering options for Category connections */
export type CategoryOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Categories. */
  field: CategoryOrderField;
};

/** Properties by which Category connections can be ordered. */
export enum CategoryOrderField {
  CreatedAt = 'CREATED_AT',
  Name = 'NAME',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * CategoryWhereInput is used for filtering Category objects.
 * Input was generated by ent.
 */
export type CategoryWhereInput = {
  and?: InputMaybe<Array<CategoryWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** children edge predicates */
  hasChildren?: InputMaybe<Scalars['Boolean']['input']>;
  hasChildrenWith?: InputMaybe<Array<CategoryWhereInput>>;
  /** createdby edge predicates */
  hasCreatedby?: InputMaybe<Scalars['Boolean']['input']>;
  hasCreatedbyWith?: InputMaybe<Array<UserWhereInput>>;
  /** parent edge predicates */
  hasParent?: InputMaybe<Scalars['Boolean']['input']>;
  hasParentWith?: InputMaybe<Array<CategoryWhereInput>>;
  /** products edge predicates */
  hasProducts?: InputMaybe<Scalars['Boolean']['input']>;
  hasProductsWith?: InputMaybe<Array<ProductWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<CategoryWhereInput>;
  or?: InputMaybe<Array<CategoryWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Coupon = Node & {
  __typename?: 'Coupon';
  amount?: Maybe<Scalars['Float']['output']>;
  code: Scalars['String']['output'];
  createdAt?: Maybe<Scalars['Time']['output']>;
  createdBy?: Maybe<User>;
  expireAt?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  orders?: Maybe<Array<Book>>;
  percentage?: Maybe<Scalars['Int']['output']>;
  status: CouponStatus;
  updatedAt?: Maybe<Scalars['Time']['output']>;
};

/** A connection to a list of items. */
export type CouponConnection = {
  __typename?: 'CouponConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CouponEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CouponEdge = {
  __typename?: 'CouponEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Coupon>;
};

/** Ordering options for Coupon connections */
export type CouponOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Coupons. */
  field: CouponOrderField;
};

/** Properties by which Coupon connections can be ordered. */
export enum CouponOrderField {
  Amount = 'AMOUNT',
  Code = 'CODE',
  CreatedAt = 'CREATED_AT',
  ExpireAt = 'EXPIRE_AT',
  Percentage = 'PERCENTAGE',
  Status = 'STATUS',
  UpdatedAt = 'UPDATED_AT'
}

/** CouponStatus is enum for the field status */
export enum CouponStatus {
  Active = 'active',
  Disabled = 'disabled'
}

/**
 * CouponWhereInput is used for filtering Coupon objects.
 * Input was generated by ent.
 */
export type CouponWhereInput = {
  /** amount field predicates */
  amount?: InputMaybe<Scalars['Float']['input']>;
  amountGT?: InputMaybe<Scalars['Float']['input']>;
  amountGTE?: InputMaybe<Scalars['Float']['input']>;
  amountIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  amountIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  amountLT?: InputMaybe<Scalars['Float']['input']>;
  amountLTE?: InputMaybe<Scalars['Float']['input']>;
  amountNEQ?: InputMaybe<Scalars['Float']['input']>;
  amountNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  amountNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<CouponWhereInput>>;
  /** code field predicates */
  code?: InputMaybe<Scalars['String']['input']>;
  codeContains?: InputMaybe<Scalars['String']['input']>;
  codeContainsFold?: InputMaybe<Scalars['String']['input']>;
  codeEqualFold?: InputMaybe<Scalars['String']['input']>;
  codeGT?: InputMaybe<Scalars['String']['input']>;
  codeGTE?: InputMaybe<Scalars['String']['input']>;
  codeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  codeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  codeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  codeLT?: InputMaybe<Scalars['String']['input']>;
  codeLTE?: InputMaybe<Scalars['String']['input']>;
  codeNEQ?: InputMaybe<Scalars['String']['input']>;
  codeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** expire_at field predicates */
  expireAt?: InputMaybe<Scalars['Time']['input']>;
  expireAtGT?: InputMaybe<Scalars['Time']['input']>;
  expireAtGTE?: InputMaybe<Scalars['Time']['input']>;
  expireAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  expireAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  expireAtLT?: InputMaybe<Scalars['Time']['input']>;
  expireAtLTE?: InputMaybe<Scalars['Time']['input']>;
  expireAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  expireAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  expireAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_by edge predicates */
  hasCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasCreatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** orders edge predicates */
  hasOrders?: InputMaybe<Scalars['Boolean']['input']>;
  hasOrdersWith?: InputMaybe<Array<BookWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CouponWhereInput>;
  or?: InputMaybe<Array<CouponWhereInput>>;
  /** percentage field predicates */
  percentage?: InputMaybe<Scalars['Int']['input']>;
  percentageGT?: InputMaybe<Scalars['Int']['input']>;
  percentageGTE?: InputMaybe<Scalars['Int']['input']>;
  percentageIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  percentageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  percentageLT?: InputMaybe<Scalars['Int']['input']>;
  percentageLTE?: InputMaybe<Scalars['Int']['input']>;
  percentageNEQ?: InputMaybe<Scalars['Int']['input']>;
  percentageNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  percentageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status?: InputMaybe<CouponStatus>;
  statusIn?: InputMaybe<Array<CouponStatus>>;
  statusNEQ?: InputMaybe<CouponStatus>;
  statusNotIn?: InputMaybe<Array<CouponStatus>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * CreateAttributesInput is used for create Attributes object.
 * Input was generated by ent.
 */
export type CreateAttributesInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  data?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  price?: InputMaybe<Scalars['Float']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  variantID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateBookInput is used for create Book object.
 * Input was generated by ent.
 */
export type CreateBookInput = {
  amount: Scalars['Float']['input'];
  cartID: Scalars['ID']['input'];
  cookie?: InputMaybe<Scalars['String']['input']>;
  couponID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  customerID?: InputMaybe<Scalars['ID']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  refundID?: InputMaybe<Scalars['ID']['input']>;
  shippingAddress: Scalars['String']['input'];
  statuIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  trackingNumber?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateBookStatusInput is used for create BookStatus object.
 * Input was generated by ent.
 */
export type CreateBookStatusInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  orderID?: InputMaybe<Scalars['ID']['input']>;
  state?: InputMaybe<BookStatusState>;
};

/**
 * CreateCartInput is used for create Cart object.
 * Input was generated by ent.
 */
export type CreateCartInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  customerID?: InputMaybe<Scalars['ID']['input']>;
  itemIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  orderID?: InputMaybe<Scalars['ID']['input']>;
  totalPrice: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateCartItemInput is used for create CartItem object.
 * Input was generated by ent.
 */
export type CreateCartItemInput = {
  addedAt?: InputMaybe<Scalars['Time']['input']>;
  cartID?: InputMaybe<Scalars['ID']['input']>;
  productID?: InputMaybe<Scalars['ID']['input']>;
  quantity: Scalars['Int']['input'];
};

/**
 * CreateCategoryInput is used for create Category object.
 * Input was generated by ent.
 */
export type CreateCategoryInput = {
  childIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdbyID?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  parentID?: InputMaybe<Scalars['ID']['input']>;
  productIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateCouponInput is used for create Coupon object.
 * Input was generated by ent.
 */
export type CreateCouponInput = {
  amount?: InputMaybe<Scalars['Float']['input']>;
  code: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdByID?: InputMaybe<Scalars['ID']['input']>;
  expireAt?: InputMaybe<Scalars['Time']['input']>;
  orderIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  percentage?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<CouponStatus>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateDiscountInput is used for create Discount object.
 * Input was generated by ent.
 */
export type CreateDiscountInput = {
  active: Scalars['Boolean']['input'];
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  endAt?: InputMaybe<Scalars['Time']['input']>;
  productID?: InputMaybe<Scalars['ID']['input']>;
  startAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * CreateProductInput is used for create Product object.
 * Input was generated by ent.
 */
export type CreateProductInput = {
  cartIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  categoryID?: InputMaybe<Scalars['ID']['input']>;
  createProductVariants?: InputMaybe<Array<CreateVariantInput>>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdbyID?: InputMaybe<Scalars['ID']['input']>;
  description: Scalars['String']['input'];
  discountIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  images?: InputMaybe<Array<Scalars['String']['input']>>;
  name: Scalars['String']['input'];
  price?: InputMaybe<Scalars['Float']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  reviewIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  sku?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  tagIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  variantIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * CreateRefundInput is used for create Refund object.
 * Input was generated by ent.
 */
export type CreateRefundInput = {
  adminNote: Scalars['String']['input'];
  amount: Scalars['Float']['input'];
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  orderID: Scalars['ID']['input'];
  reason: Scalars['String']['input'];
  statuIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateRefundStatusInput is used for create RefundStatus object.
 * Input was generated by ent.
 */
export type CreateRefundStatusInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  refundID?: InputMaybe<Scalars['ID']['input']>;
  state?: InputMaybe<RefundStatusState>;
};

/**
 * CreateReviewInput is used for create Review object.
 * Input was generated by ent.
 */
export type CreateReviewInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  customerID?: InputMaybe<Scalars['ID']['input']>;
  description: Scalars['String']['input'];
  note: Scalars['Int']['input'];
  productID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateTagInput is used for create Tag object.
 * Input was generated by ent.
 */
export type CreateTagInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  name: Scalars['String']['input'];
  productIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  banned?: InputMaybe<Scalars['Boolean']['input']>;
  cartIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  categoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  couponIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  email: Scalars['String']['input'];
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  managerID?: InputMaybe<Scalars['ID']['input']>;
  orderIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  password: Scalars['String']['input'];
  phone: Scalars['String']['input'];
  productIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  reviewIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  role?: InputMaybe<UserRole>;
  supervisorIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  uid: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  username: Scalars['String']['input'];
};

/**
 * CreateVariantInput is used for create Variant object.
 * Input was generated by ent.
 */
export type CreateVariantInput = {
  attributeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  createVariantWithAttributes?: InputMaybe<Array<InputMaybe<CreateAttributesInput>>>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  name: Scalars['String']['input'];
  optionType?: InputMaybe<VariantOptionType>;
  productID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

export type DeleteProductImages = {
  __typename?: 'DeleteProductImages';
  deleted: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
};

export type Discount = Node & {
  __typename?: 'Discount';
  active: Scalars['Boolean']['output'];
  createdAt?: Maybe<Scalars['Time']['output']>;
  endAt?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  product?: Maybe<Product>;
  startAt?: Maybe<Scalars['Time']['output']>;
  updatedAt?: Maybe<Scalars['Time']['output']>;
  value?: Maybe<Scalars['Int']['output']>;
};

/** A connection to a list of items. */
export type DiscountConnection = {
  __typename?: 'DiscountConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscountEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DiscountEdge = {
  __typename?: 'DiscountEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Discount>;
};

/** Ordering options for Discount connections */
export type DiscountOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Discounts. */
  field: DiscountOrderField;
};

/** Properties by which Discount connections can be ordered. */
export enum DiscountOrderField {
  Active = 'ACTIVE',
  CreatedAt = 'CREATED_AT',
  EndAt = 'END_AT',
  StartAt = 'START_AT',
  UpdatedAt = 'UPDATED_AT',
  Value = 'VALUE'
}

/**
 * DiscountWhereInput is used for filtering Discount objects.
 * Input was generated by ent.
 */
export type DiscountWhereInput = {
  /** active field predicates */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  activeNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<DiscountWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** end_at field predicates */
  endAt?: InputMaybe<Scalars['Time']['input']>;
  endAtGT?: InputMaybe<Scalars['Time']['input']>;
  endAtGTE?: InputMaybe<Scalars['Time']['input']>;
  endAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  endAtLT?: InputMaybe<Scalars['Time']['input']>;
  endAtLTE?: InputMaybe<Scalars['Time']['input']>;
  endAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  endAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** product edge predicates */
  hasProduct?: InputMaybe<Scalars['Boolean']['input']>;
  hasProductWith?: InputMaybe<Array<ProductWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<DiscountWhereInput>;
  or?: InputMaybe<Array<DiscountWhereInput>>;
  /** start_at field predicates */
  startAt?: InputMaybe<Scalars['Time']['input']>;
  startAtGT?: InputMaybe<Scalars['Time']['input']>;
  startAtGTE?: InputMaybe<Scalars['Time']['input']>;
  startAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  startAtLT?: InputMaybe<Scalars['Time']['input']>;
  startAtLTE?: InputMaybe<Scalars['Time']['input']>;
  startAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  startAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** value field predicates */
  value?: InputMaybe<Scalars['Int']['input']>;
  valueGT?: InputMaybe<Scalars['Int']['input']>;
  valueGTE?: InputMaybe<Scalars['Int']['input']>;
  valueIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  valueIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  valueLT?: InputMaybe<Scalars['Int']['input']>;
  valueLTE?: InputMaybe<Scalars['Int']['input']>;
  valueNEQ?: InputMaybe<Scalars['Int']['input']>;
  valueNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  valueNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  addCoupon: Book;
  addImages: Array<Maybe<AddProductImages>>;
  createAttributes: Attributes;
  createBook: Book;
  createBookStatus: BookStatus;
  createCart: Cart;
  createCategory: Category;
  createCoupon: Coupon;
  createDiscount: Discount;
  createManyCarts: Array<Maybe<Cart>>;
  createManyCategories: Array<Maybe<Category>>;
  createManyCoupons: Array<Maybe<Coupon>>;
  createManyDiscounts: Array<Maybe<Discount>>;
  createManyProducts: Array<Maybe<Product>>;
  createManyTags: Array<Maybe<Tag>>;
  createManyVariants: Array<Maybe<Variant>>;
  createProduct: Product;
  createRefund: Refund;
  createRefundStatus: RefundStatus;
  createReview: Review;
  createTag: Tag;
  createUser: User;
  createVariant: Variant;
  deleteAllCategories: Scalars['Boolean']['output'];
  deleteAllDiscounts: Scalars['Boolean']['output'];
  deleteAllProducts: Scalars['Boolean']['output'];
  deleteAttributes: Scalars['Boolean']['output'];
  deleteBook: Scalars['Boolean']['output'];
  deleteBookStatus: Scalars['Boolean']['output'];
  deleteCart: Scalars['Boolean']['output'];
  deleteCategory: Scalars['Boolean']['output'];
  deleteCoupon: Scalars['Boolean']['output'];
  deleteDiscount: Scalars['Boolean']['output'];
  deleteImages: Array<Maybe<DeleteProductImages>>;
  deleteProduct: Scalars['Boolean']['output'];
  deleteRefund: Scalars['Boolean']['output'];
  deleteRefundStatus: Scalars['Boolean']['output'];
  deleteReview: Scalars['Boolean']['output'];
  deleteTag: Scalars['Boolean']['output'];
  deleteUser: Scalars['Boolean']['output'];
  deleteVariant: Scalars['Boolean']['output'];
  updateAttributes: Attributes;
  updateBook: Book;
  updateBookStatus: BookStatus;
  updateCart: Cart;
  updateCategory: Category;
  updateCoupon: Coupon;
  updateDiscount: Discount;
  updateProduct: Product;
  updateRefund: Refund;
  updateRefundStatus: RefundStatus;
  updateReview: Review;
  updateTag: Tag;
  updateUser: User;
  updateVariant: Variant;
};


export type MutationAddCouponArgs = {
  couponID: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};


export type MutationAddImagesArgs = {
  id: Scalars['ID']['input'];
  images: Array<InputMaybe<Scalars['Upload']['input']>>;
};


export type MutationCreateAttributesArgs = {
  image?: InputMaybe<Scalars['Upload']['input']>;
  input: CreateAttributesInput;
};


export type MutationCreateBookArgs = {
  image?: InputMaybe<Scalars['Upload']['input']>;
  input: CreateBookInput;
};


export type MutationCreateBookStatusArgs = {
  input: CreateBookStatusInput;
};


export type MutationCreateCartArgs = {
  input: CreateCartInput;
};


export type MutationCreateCategoryArgs = {
  input: CreateCategoryInput;
};


export type MutationCreateCouponArgs = {
  input: CreateCouponInput;
};


export type MutationCreateDiscountArgs = {
  input: CreateDiscountInput;
};


export type MutationCreateManyCartsArgs = {
  input: Array<InputMaybe<CreateCartInput>>;
};


export type MutationCreateManyCategoriesArgs = {
  input: Array<InputMaybe<CreateCategoryInput>>;
};


export type MutationCreateManyCouponsArgs = {
  input: Array<InputMaybe<CreateCouponInput>>;
};


export type MutationCreateManyDiscountsArgs = {
  input: Array<InputMaybe<CreateDiscountInput>>;
};


export type MutationCreateManyProductsArgs = {
  input: Array<InputMaybe<CreateProductInput>>;
};


export type MutationCreateManyTagsArgs = {
  input: Array<InputMaybe<CreateTagInput>>;
};


export type MutationCreateManyVariantsArgs = {
  input: Array<InputMaybe<CreateVariantInput>>;
};


export type MutationCreateProductArgs = {
  images: Array<InputMaybe<Scalars['Upload']['input']>>;
  input: CreateProductInput;
  variants?: InputMaybe<Array<InputMaybe<CreateVariantInput>>>;
};


export type MutationCreateRefundArgs = {
  input: CreateRefundInput;
};


export type MutationCreateRefundStatusArgs = {
  input: CreateRefundStatusInput;
};


export type MutationCreateReviewArgs = {
  input: CreateReviewInput;
};


export type MutationCreateTagArgs = {
  input: CreateTagInput;
};


export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


export type MutationCreateVariantArgs = {
  input: CreateVariantInput;
};


export type MutationDeleteAttributesArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteBookArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteBookStatusArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteCartArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteCategoryArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteCouponArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteDiscountArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteImagesArgs = {
  id: Scalars['ID']['input'];
  images: Array<InputMaybe<Scalars['String']['input']>>;
};


export type MutationDeleteProductArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteRefundArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteRefundStatusArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteReviewArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteTagArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteUserArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteVariantArgs = {
  id: Scalars['ID']['input'];
};


export type MutationUpdateAttributesArgs = {
  id: Scalars['ID']['input'];
  input: UpdateAttributesInput;
};


export type MutationUpdateBookArgs = {
  id: Scalars['ID']['input'];
  image?: InputMaybe<Scalars['Upload']['input']>;
  input: UpdateBookInput;
};


export type MutationUpdateBookStatusArgs = {
  id: Scalars['ID']['input'];
  input: UpdateBookStatusInput;
};


export type MutationUpdateCartArgs = {
  id: Scalars['ID']['input'];
  input: UpdateCartInput;
};


export type MutationUpdateCategoryArgs = {
  id: Scalars['ID']['input'];
  input: UpdateCategoryInput;
};


export type MutationUpdateCouponArgs = {
  id: Scalars['ID']['input'];
  input: UpdateCouponInput;
};


export type MutationUpdateDiscountArgs = {
  id: Scalars['ID']['input'];
  input: UpdateDiscountInput;
};


export type MutationUpdateProductArgs = {
  id: Scalars['ID']['input'];
  input: UpdateProductInput;
  productImages?: InputMaybe<Array<InputMaybe<Scalars['Upload']['input']>>>;
  variants?: InputMaybe<Array<InputMaybe<CreateVariantInput>>>;
  variantsImages?: InputMaybe<Array<InputMaybe<Scalars['Upload']['input']>>>;
};


export type MutationUpdateRefundArgs = {
  id: Scalars['ID']['input'];
  input: UpdateRefundInput;
};


export type MutationUpdateRefundStatusArgs = {
  id: Scalars['ID']['input'];
  input: UpdateRefundStatusInput;
};


export type MutationUpdateReviewArgs = {
  id: Scalars['ID']['input'];
  input: UpdateReviewInput;
};


export type MutationUpdateTagArgs = {
  id: Scalars['ID']['input'];
  input: UpdateTagInput;
};


export type MutationUpdateUserArgs = {
  id: Scalars['ID']['input'];
  input: UpdateUserInput;
};


export type MutationUpdateVariantArgs = {
  id: Scalars['ID']['input'];
  input: UpdateVariantInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Product = Node & {
  __typename?: 'Product';
  carts?: Maybe<Array<CartItem>>;
  category?: Maybe<Category>;
  createdAt?: Maybe<Scalars['Time']['output']>;
  createdby?: Maybe<User>;
  description: Scalars['String']['output'];
  discounts?: Maybe<Array<Discount>>;
  id: Scalars['ID']['output'];
  images?: Maybe<Array<Scalars['String']['output']>>;
  name: Scalars['String']['output'];
  price?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  reviews?: Maybe<Array<Review>>;
  sku?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['Boolean']['output']>;
  tags?: Maybe<Array<Tag>>;
  updatedAt?: Maybe<Scalars['Time']['output']>;
  variants?: Maybe<Array<Variant>>;
};

/** A connection to a list of items. */
export type ProductConnection = {
  __typename?: 'ProductConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProductEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ProductEdge = {
  __typename?: 'ProductEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Product>;
};

/** Ordering options for Product connections */
export type ProductOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Products. */
  field: ProductOrderField;
};

/** Properties by which Product connections can be ordered. */
export enum ProductOrderField {
  CreatedAt = 'CREATED_AT',
  Description = 'DESCRIPTION',
  Name = 'NAME',
  Price = 'PRICE',
  Quantity = 'QUANTITY',
  Sku = 'SKU',
  Status = 'STATUS',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * ProductWhereInput is used for filtering Product objects.
 * Input was generated by ent.
 */
export type ProductWhereInput = {
  and?: InputMaybe<Array<ProductWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** carts edge predicates */
  hasCarts?: InputMaybe<Scalars['Boolean']['input']>;
  hasCartsWith?: InputMaybe<Array<CartItemWhereInput>>;
  /** category edge predicates */
  hasCategory?: InputMaybe<Scalars['Boolean']['input']>;
  hasCategoryWith?: InputMaybe<Array<CategoryWhereInput>>;
  /** createdby edge predicates */
  hasCreatedby?: InputMaybe<Scalars['Boolean']['input']>;
  hasCreatedbyWith?: InputMaybe<Array<UserWhereInput>>;
  /** discounts edge predicates */
  hasDiscounts?: InputMaybe<Scalars['Boolean']['input']>;
  hasDiscountsWith?: InputMaybe<Array<DiscountWhereInput>>;
  /** reviews edge predicates */
  hasReviews?: InputMaybe<Scalars['Boolean']['input']>;
  hasReviewsWith?: InputMaybe<Array<ReviewWhereInput>>;
  /** tags edge predicates */
  hasTags?: InputMaybe<Scalars['Boolean']['input']>;
  hasTagsWith?: InputMaybe<Array<TagWhereInput>>;
  /** variants edge predicates */
  hasVariants?: InputMaybe<Scalars['Boolean']['input']>;
  hasVariantsWith?: InputMaybe<Array<VariantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ProductWhereInput>;
  or?: InputMaybe<Array<ProductWhereInput>>;
  /** price field predicates */
  price?: InputMaybe<Scalars['Float']['input']>;
  priceGT?: InputMaybe<Scalars['Float']['input']>;
  priceGTE?: InputMaybe<Scalars['Float']['input']>;
  priceIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  priceIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  priceLT?: InputMaybe<Scalars['Float']['input']>;
  priceLTE?: InputMaybe<Scalars['Float']['input']>;
  priceNEQ?: InputMaybe<Scalars['Float']['input']>;
  priceNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  priceNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** quantity field predicates */
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quantityGT?: InputMaybe<Scalars['Int']['input']>;
  quantityGTE?: InputMaybe<Scalars['Int']['input']>;
  quantityIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  quantityIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  quantityLT?: InputMaybe<Scalars['Int']['input']>;
  quantityLTE?: InputMaybe<Scalars['Int']['input']>;
  quantityNEQ?: InputMaybe<Scalars['Int']['input']>;
  quantityNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  quantityNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** sku field predicates */
  sku?: InputMaybe<Scalars['String']['input']>;
  skuContains?: InputMaybe<Scalars['String']['input']>;
  skuContainsFold?: InputMaybe<Scalars['String']['input']>;
  skuEqualFold?: InputMaybe<Scalars['String']['input']>;
  skuGT?: InputMaybe<Scalars['String']['input']>;
  skuGTE?: InputMaybe<Scalars['String']['input']>;
  skuHasPrefix?: InputMaybe<Scalars['String']['input']>;
  skuHasSuffix?: InputMaybe<Scalars['String']['input']>;
  skuIn?: InputMaybe<Array<Scalars['String']['input']>>;
  skuIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  skuLT?: InputMaybe<Scalars['String']['input']>;
  skuLTE?: InputMaybe<Scalars['String']['input']>;
  skuNEQ?: InputMaybe<Scalars['String']['input']>;
  skuNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  skuNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status?: InputMaybe<Scalars['Boolean']['input']>;
  statusIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  statusNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  statusNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Query = {
  __typename?: 'Query';
  attributesSlice: AttributesConnection;
  bookStatusSlice: BookStatusConnection;
  books: BookConnection;
  cartItems: CartItemConnection;
  carts: CartConnection;
  categories: CategoryConnection;
  coupons: CouponConnection;
  discounts: DiscountConnection;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  products: ProductConnection;
  refundStatusSlice: RefundStatusConnection;
  refunds: RefundConnection;
  reviews: ReviewConnection;
  tags: TagConnection;
  users: UserConnection;
  variants: VariantConnection;
};


export type QueryAttributesSliceArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<AttributesOrder>;
  where?: InputMaybe<AttributesWhereInput>;
};


export type QueryBookStatusSliceArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BookStatusWhereInput>;
};


export type QueryBooksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BookOrder>>;
  where?: InputMaybe<BookWhereInput>;
};


export type QueryCartItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<CartItemOrder>;
  where?: InputMaybe<CartItemWhereInput>;
};


export type QueryCartsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<CartOrder>;
  where?: InputMaybe<CartWhereInput>;
};


export type QueryCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<CategoryOrder>;
  where?: InputMaybe<CategoryWhereInput>;
};


export type QueryCouponsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<CouponOrder>;
  where?: InputMaybe<CouponWhereInput>;
};


export type QueryDiscountsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DiscountOrder>;
  where?: InputMaybe<DiscountWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryProductsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ProductOrder>;
  where?: InputMaybe<ProductWhereInput>;
};


export type QueryRefundStatusSliceArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<RefundStatusWhereInput>;
};


export type QueryRefundsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<RefundOrder>;
  where?: InputMaybe<RefundWhereInput>;
};


export type QueryReviewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ReviewOrder>;
  where?: InputMaybe<ReviewWhereInput>;
};


export type QueryTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TagOrder>;
  where?: InputMaybe<TagWhereInput>;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserOrder>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryVariantsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<VariantOrder>;
  where?: InputMaybe<VariantWhereInput>;
};

export type Refund = Node & {
  __typename?: 'Refund';
  adminNote: Scalars['String']['output'];
  amount: Scalars['Float']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  order: Book;
  reason: Scalars['String']['output'];
  status?: Maybe<Array<RefundStatus>>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type RefundConnection = {
  __typename?: 'RefundConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RefundEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RefundEdge = {
  __typename?: 'RefundEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Refund>;
};

/** Ordering options for Refund connections */
export type RefundOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Refunds. */
  field: RefundOrderField;
};

/** Properties by which Refund connections can be ordered. */
export enum RefundOrderField {
  AdminNote = 'ADMIN_NOTE',
  Amount = 'AMOUNT',
  CreatedAt = 'CREATED_AT',
  Reason = 'REASON',
  UpdatedAt = 'UPDATED_AT'
}

export type RefundStatus = Node & {
  __typename?: 'RefundStatus';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  refund?: Maybe<Refund>;
  state: RefundStatusState;
};

/** A connection to a list of items. */
export type RefundStatusConnection = {
  __typename?: 'RefundStatusConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RefundStatusEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type RefundStatusEdge = {
  __typename?: 'RefundStatusEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RefundStatus>;
};

/** RefundStatusState is enum for the field state */
export enum RefundStatusState {
  Approved = 'approved',
  Pending = 'pending',
  Processed = 'processed',
  Rejected = 'rejected'
}

/**
 * RefundStatusWhereInput is used for filtering RefundStatus objects.
 * Input was generated by ent.
 */
export type RefundStatusWhereInput = {
  and?: InputMaybe<Array<RefundStatusWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** refund edge predicates */
  hasRefund?: InputMaybe<Scalars['Boolean']['input']>;
  hasRefundWith?: InputMaybe<Array<RefundWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<RefundStatusWhereInput>;
  or?: InputMaybe<Array<RefundStatusWhereInput>>;
  /** state field predicates */
  state?: InputMaybe<RefundStatusState>;
  stateIn?: InputMaybe<Array<RefundStatusState>>;
  stateNEQ?: InputMaybe<RefundStatusState>;
  stateNotIn?: InputMaybe<Array<RefundStatusState>>;
};

/**
 * RefundWhereInput is used for filtering Refund objects.
 * Input was generated by ent.
 */
export type RefundWhereInput = {
  /** admin_note field predicates */
  adminNote?: InputMaybe<Scalars['String']['input']>;
  adminNoteContains?: InputMaybe<Scalars['String']['input']>;
  adminNoteContainsFold?: InputMaybe<Scalars['String']['input']>;
  adminNoteEqualFold?: InputMaybe<Scalars['String']['input']>;
  adminNoteGT?: InputMaybe<Scalars['String']['input']>;
  adminNoteGTE?: InputMaybe<Scalars['String']['input']>;
  adminNoteHasPrefix?: InputMaybe<Scalars['String']['input']>;
  adminNoteHasSuffix?: InputMaybe<Scalars['String']['input']>;
  adminNoteIn?: InputMaybe<Array<Scalars['String']['input']>>;
  adminNoteLT?: InputMaybe<Scalars['String']['input']>;
  adminNoteLTE?: InputMaybe<Scalars['String']['input']>;
  adminNoteNEQ?: InputMaybe<Scalars['String']['input']>;
  adminNoteNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** amount field predicates */
  amount?: InputMaybe<Scalars['Float']['input']>;
  amountGT?: InputMaybe<Scalars['Float']['input']>;
  amountGTE?: InputMaybe<Scalars['Float']['input']>;
  amountIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  amountLT?: InputMaybe<Scalars['Float']['input']>;
  amountLTE?: InputMaybe<Scalars['Float']['input']>;
  amountNEQ?: InputMaybe<Scalars['Float']['input']>;
  amountNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  and?: InputMaybe<Array<RefundWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** order edge predicates */
  hasOrder?: InputMaybe<Scalars['Boolean']['input']>;
  hasOrderWith?: InputMaybe<Array<BookWhereInput>>;
  /** status edge predicates */
  hasStatus?: InputMaybe<Scalars['Boolean']['input']>;
  hasStatusWith?: InputMaybe<Array<RefundStatusWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<RefundWhereInput>;
  or?: InputMaybe<Array<RefundWhereInput>>;
  /** reason field predicates */
  reason?: InputMaybe<Scalars['String']['input']>;
  reasonContains?: InputMaybe<Scalars['String']['input']>;
  reasonContainsFold?: InputMaybe<Scalars['String']['input']>;
  reasonEqualFold?: InputMaybe<Scalars['String']['input']>;
  reasonGT?: InputMaybe<Scalars['String']['input']>;
  reasonGTE?: InputMaybe<Scalars['String']['input']>;
  reasonHasPrefix?: InputMaybe<Scalars['String']['input']>;
  reasonHasSuffix?: InputMaybe<Scalars['String']['input']>;
  reasonIn?: InputMaybe<Array<Scalars['String']['input']>>;
  reasonLT?: InputMaybe<Scalars['String']['input']>;
  reasonLTE?: InputMaybe<Scalars['String']['input']>;
  reasonNEQ?: InputMaybe<Scalars['String']['input']>;
  reasonNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Review = Node & {
  __typename?: 'Review';
  createdAt: Scalars['Time']['output'];
  customer?: Maybe<User>;
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  note: Scalars['Int']['output'];
  product?: Maybe<Product>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type ReviewConnection = {
  __typename?: 'ReviewConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReviewEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ReviewEdge = {
  __typename?: 'ReviewEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Review>;
};

/** Ordering options for Review connections */
export type ReviewOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Reviews. */
  field: ReviewOrderField;
};

/** Properties by which Review connections can be ordered. */
export enum ReviewOrderField {
  CreatedAt = 'CREATED_AT',
  Note = 'NOTE',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * ReviewWhereInput is used for filtering Review objects.
 * Input was generated by ent.
 */
export type ReviewWhereInput = {
  and?: InputMaybe<Array<ReviewWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** customer edge predicates */
  hasCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  hasCustomerWith?: InputMaybe<Array<UserWhereInput>>;
  /** product edge predicates */
  hasProduct?: InputMaybe<Scalars['Boolean']['input']>;
  hasProductWith?: InputMaybe<Array<ProductWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<ReviewWhereInput>;
  /** note field predicates */
  note?: InputMaybe<Scalars['Int']['input']>;
  noteGT?: InputMaybe<Scalars['Int']['input']>;
  noteGTE?: InputMaybe<Scalars['Int']['input']>;
  noteIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  noteLT?: InputMaybe<Scalars['Int']['input']>;
  noteLTE?: InputMaybe<Scalars['Int']['input']>;
  noteNEQ?: InputMaybe<Scalars['Int']['input']>;
  noteNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  or?: InputMaybe<Array<ReviewWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Tag = Node & {
  __typename?: 'Tag';
  createdAt?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  products?: Maybe<Array<Product>>;
  updatedAt?: Maybe<Scalars['Time']['output']>;
};

/** A connection to a list of items. */
export type TagConnection = {
  __typename?: 'TagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TagEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type TagEdge = {
  __typename?: 'TagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Tag>;
};

/** Ordering options for Tag connections */
export type TagOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Tags. */
  field: TagOrderField;
};

/** Properties by which Tag connections can be ordered. */
export enum TagOrderField {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * TagWhereInput is used for filtering Tag objects.
 * Input was generated by ent.
 */
export type TagWhereInput = {
  and?: InputMaybe<Array<TagWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** products edge predicates */
  hasProducts?: InputMaybe<Scalars['Boolean']['input']>;
  hasProductsWith?: InputMaybe<Array<ProductWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<TagWhereInput>;
  or?: InputMaybe<Array<TagWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * UpdateAttributesInput is used for update Attributes object.
 * Input was generated by ent.
 */
export type UpdateAttributesInput = {
  clearData?: InputMaybe<Scalars['Boolean']['input']>;
  clearImage?: InputMaybe<Scalars['Boolean']['input']>;
  clearPrice?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearVariant?: InputMaybe<Scalars['Boolean']['input']>;
  data?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price?: InputMaybe<Scalars['Float']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  variantID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateBookInput is used for update Book object.
 * Input was generated by ent.
 */
export type UpdateBookInput = {
  addStatuIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  amount?: InputMaybe<Scalars['Float']['input']>;
  cartID?: InputMaybe<Scalars['ID']['input']>;
  clearCookie?: InputMaybe<Scalars['Boolean']['input']>;
  clearCoupon?: InputMaybe<Scalars['Boolean']['input']>;
  clearCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  clearImage?: InputMaybe<Scalars['Boolean']['input']>;
  clearRefund?: InputMaybe<Scalars['Boolean']['input']>;
  clearStatus?: InputMaybe<Scalars['Boolean']['input']>;
  clearTrackingNumber?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  cookie?: InputMaybe<Scalars['String']['input']>;
  couponID?: InputMaybe<Scalars['ID']['input']>;
  customerID?: InputMaybe<Scalars['ID']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
  refundID?: InputMaybe<Scalars['ID']['input']>;
  removeStatuIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  shippingAddress?: InputMaybe<Scalars['String']['input']>;
  trackingNumber?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateBookStatusInput is used for update BookStatus object.
 * Input was generated by ent.
 */
export type UpdateBookStatusInput = {
  clearOrder?: InputMaybe<Scalars['Boolean']['input']>;
  orderID?: InputMaybe<Scalars['ID']['input']>;
  state?: InputMaybe<BookStatusState>;
};

/**
 * UpdateCartInput is used for update Cart object.
 * Input was generated by ent.
 */
export type UpdateCartInput = {
  addItemIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  clearItems?: InputMaybe<Scalars['Boolean']['input']>;
  clearOrder?: InputMaybe<Scalars['Boolean']['input']>;
  customerID?: InputMaybe<Scalars['ID']['input']>;
  orderID?: InputMaybe<Scalars['ID']['input']>;
  removeItemIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  totalPrice?: InputMaybe<Scalars['Float']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateCartItemInput is used for update CartItem object.
 * Input was generated by ent.
 */
export type UpdateCartItemInput = {
  addedAt?: InputMaybe<Scalars['Time']['input']>;
  cartID?: InputMaybe<Scalars['ID']['input']>;
  clearCart?: InputMaybe<Scalars['Boolean']['input']>;
  clearProduct?: InputMaybe<Scalars['Boolean']['input']>;
  productID?: InputMaybe<Scalars['ID']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * UpdateCategoryInput is used for update Category object.
 * Input was generated by ent.
 */
export type UpdateCategoryInput = {
  addChildIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addProductIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearChildren?: InputMaybe<Scalars['Boolean']['input']>;
  clearCreatedby?: InputMaybe<Scalars['Boolean']['input']>;
  clearParent?: InputMaybe<Scalars['Boolean']['input']>;
  clearProducts?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  createdbyID?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentID?: InputMaybe<Scalars['ID']['input']>;
  removeChildIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeProductIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateCouponInput is used for update Coupon object.
 * Input was generated by ent.
 */
export type UpdateCouponInput = {
  addOrderIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  amount?: InputMaybe<Scalars['Float']['input']>;
  clearAmount?: InputMaybe<Scalars['Boolean']['input']>;
  clearCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  clearExpireAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearOrders?: InputMaybe<Scalars['Boolean']['input']>;
  clearPercentage?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  createdByID?: InputMaybe<Scalars['ID']['input']>;
  expireAt?: InputMaybe<Scalars['Time']['input']>;
  percentage?: InputMaybe<Scalars['Int']['input']>;
  removeOrderIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  status?: InputMaybe<CouponStatus>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateDiscountInput is used for update Discount object.
 * Input was generated by ent.
 */
export type UpdateDiscountInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  clearEndAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearProduct?: InputMaybe<Scalars['Boolean']['input']>;
  clearStartAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  endAt?: InputMaybe<Scalars['Time']['input']>;
  productID?: InputMaybe<Scalars['ID']['input']>;
  startAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateProductInput is used for update Product object.
 * Input was generated by ent.
 */
export type UpdateProductInput = {
  addCartIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addDiscountIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addReviewIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addTagIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addVariantIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  appendImages?: InputMaybe<Array<Scalars['String']['input']>>;
  categoryID?: InputMaybe<Scalars['ID']['input']>;
  clearCarts?: InputMaybe<Scalars['Boolean']['input']>;
  clearCategory?: InputMaybe<Scalars['Boolean']['input']>;
  clearCreatedby?: InputMaybe<Scalars['Boolean']['input']>;
  clearDiscounts?: InputMaybe<Scalars['Boolean']['input']>;
  clearImages?: InputMaybe<Scalars['Boolean']['input']>;
  clearPrice?: InputMaybe<Scalars['Boolean']['input']>;
  clearQuantity?: InputMaybe<Scalars['Boolean']['input']>;
  clearReviews?: InputMaybe<Scalars['Boolean']['input']>;
  clearSku?: InputMaybe<Scalars['Boolean']['input']>;
  clearStatus?: InputMaybe<Scalars['Boolean']['input']>;
  clearTags?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearVariants?: InputMaybe<Scalars['Boolean']['input']>;
  createdbyID?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  images?: InputMaybe<Array<Scalars['String']['input']>>;
  name?: InputMaybe<Scalars['String']['input']>;
  price?: InputMaybe<Scalars['Float']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  removeCartIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeDiscountIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeReviewIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeTagIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeVariantIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  sku?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateRefundInput is used for update Refund object.
 * Input was generated by ent.
 */
export type UpdateRefundInput = {
  addStatuIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  adminNote?: InputMaybe<Scalars['String']['input']>;
  amount?: InputMaybe<Scalars['Float']['input']>;
  clearStatus?: InputMaybe<Scalars['Boolean']['input']>;
  orderID?: InputMaybe<Scalars['ID']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  removeStatuIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateRefundStatusInput is used for update RefundStatus object.
 * Input was generated by ent.
 */
export type UpdateRefundStatusInput = {
  clearRefund?: InputMaybe<Scalars['Boolean']['input']>;
  refundID?: InputMaybe<Scalars['ID']['input']>;
  state?: InputMaybe<RefundStatusState>;
};

/**
 * UpdateReviewInput is used for update Review object.
 * Input was generated by ent.
 */
export type UpdateReviewInput = {
  clearCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  clearProduct?: InputMaybe<Scalars['Boolean']['input']>;
  customerID?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['Int']['input']>;
  productID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateTagInput is used for update Tag object.
 * Input was generated by ent.
 */
export type UpdateTagInput = {
  addProductIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearProducts?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  removeProductIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addCartIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addCategoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addCouponIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addOrderIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addProductIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addReviewIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addSupervisorIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  banned?: InputMaybe<Scalars['Boolean']['input']>;
  clearCarts?: InputMaybe<Scalars['Boolean']['input']>;
  clearCategories?: InputMaybe<Scalars['Boolean']['input']>;
  clearCoupons?: InputMaybe<Scalars['Boolean']['input']>;
  clearManager?: InputMaybe<Scalars['Boolean']['input']>;
  clearOrders?: InputMaybe<Scalars['Boolean']['input']>;
  clearProducts?: InputMaybe<Scalars['Boolean']['input']>;
  clearReviews?: InputMaybe<Scalars['Boolean']['input']>;
  clearSupervisor?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  managerID?: InputMaybe<Scalars['ID']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  removeCartIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeCategoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeCouponIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeOrderIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeProductIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeReviewIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeSupervisorIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  role?: InputMaybe<UserRole>;
  uid?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateVariantInput is used for update Variant object.
 * Input was generated by ent.
 */
export type UpdateVariantInput = {
  addAttributeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearAttributes?: InputMaybe<Scalars['Boolean']['input']>;
  clearProduct?: InputMaybe<Scalars['Boolean']['input']>;
  clearUpdatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  optionType?: InputMaybe<VariantOptionType>;
  productID?: InputMaybe<Scalars['ID']['input']>;
  removeAttributeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

export type User = Node & {
  __typename?: 'User';
  banned: Scalars['Boolean']['output'];
  carts?: Maybe<Array<Cart>>;
  categories?: Maybe<Array<Category>>;
  coupons?: Maybe<Array<Coupon>>;
  createdAt?: Maybe<Scalars['Time']['output']>;
  email: Scalars['String']['output'];
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  manager?: Maybe<User>;
  orders?: Maybe<Array<Book>>;
  phone: Scalars['String']['output'];
  products?: Maybe<Array<Product>>;
  reviews?: Maybe<Array<Review>>;
  role: UserRole;
  supervisor?: Maybe<Array<User>>;
  uid: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['Time']['output']>;
  username: Scalars['String']['output'];
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** Ordering options for User connections */
export type UserOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Users. */
  field: UserOrderField;
};

/** Properties by which User connections can be ordered. */
export enum UserOrderField {
  Banned = 'BANNED',
  CreatedAt = 'CREATED_AT',
  Email = 'EMAIL',
  FirstName = 'FIRST_NAME',
  LastName = 'LAST_NAME',
  Password = 'PASSWORD',
  Phone = 'PHONE',
  Uid = 'UID',
  UpdatedAt = 'UPDATED_AT',
  Username = 'USERNAME'
}

/** UserRole is enum for the field role */
export enum UserRole {
  Admin = 'Admin',
  Customer = 'Customer'
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** banned field predicates */
  banned?: InputMaybe<Scalars['Boolean']['input']>;
  bannedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** first_name field predicates */
  firstName?: InputMaybe<Scalars['String']['input']>;
  firstNameContains?: InputMaybe<Scalars['String']['input']>;
  firstNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  firstNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  firstNameGT?: InputMaybe<Scalars['String']['input']>;
  firstNameGTE?: InputMaybe<Scalars['String']['input']>;
  firstNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  firstNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  firstNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  firstNameLT?: InputMaybe<Scalars['String']['input']>;
  firstNameLTE?: InputMaybe<Scalars['String']['input']>;
  firstNameNEQ?: InputMaybe<Scalars['String']['input']>;
  firstNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** carts edge predicates */
  hasCarts?: InputMaybe<Scalars['Boolean']['input']>;
  hasCartsWith?: InputMaybe<Array<CartWhereInput>>;
  /** categories edge predicates */
  hasCategories?: InputMaybe<Scalars['Boolean']['input']>;
  hasCategoriesWith?: InputMaybe<Array<CategoryWhereInput>>;
  /** coupons edge predicates */
  hasCoupons?: InputMaybe<Scalars['Boolean']['input']>;
  hasCouponsWith?: InputMaybe<Array<CouponWhereInput>>;
  /** manager edge predicates */
  hasManager?: InputMaybe<Scalars['Boolean']['input']>;
  hasManagerWith?: InputMaybe<Array<UserWhereInput>>;
  /** orders edge predicates */
  hasOrders?: InputMaybe<Scalars['Boolean']['input']>;
  hasOrdersWith?: InputMaybe<Array<BookWhereInput>>;
  /** products edge predicates */
  hasProducts?: InputMaybe<Scalars['Boolean']['input']>;
  hasProductsWith?: InputMaybe<Array<ProductWhereInput>>;
  /** reviews edge predicates */
  hasReviews?: InputMaybe<Scalars['Boolean']['input']>;
  hasReviewsWith?: InputMaybe<Array<ReviewWhereInput>>;
  /** supervisor edge predicates */
  hasSupervisor?: InputMaybe<Scalars['Boolean']['input']>;
  hasSupervisorWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_name field predicates */
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastNameContains?: InputMaybe<Scalars['String']['input']>;
  lastNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  lastNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  lastNameGT?: InputMaybe<Scalars['String']['input']>;
  lastNameGTE?: InputMaybe<Scalars['String']['input']>;
  lastNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  lastNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  lastNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  lastNameLT?: InputMaybe<Scalars['String']['input']>;
  lastNameLTE?: InputMaybe<Scalars['String']['input']>;
  lastNameNEQ?: InputMaybe<Scalars['String']['input']>;
  lastNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** phone field predicates */
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneContains?: InputMaybe<Scalars['String']['input']>;
  phoneContainsFold?: InputMaybe<Scalars['String']['input']>;
  phoneEqualFold?: InputMaybe<Scalars['String']['input']>;
  phoneGT?: InputMaybe<Scalars['String']['input']>;
  phoneGTE?: InputMaybe<Scalars['String']['input']>;
  phoneHasPrefix?: InputMaybe<Scalars['String']['input']>;
  phoneHasSuffix?: InputMaybe<Scalars['String']['input']>;
  phoneIn?: InputMaybe<Array<Scalars['String']['input']>>;
  phoneLT?: InputMaybe<Scalars['String']['input']>;
  phoneLTE?: InputMaybe<Scalars['String']['input']>;
  phoneNEQ?: InputMaybe<Scalars['String']['input']>;
  phoneNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** role field predicates */
  role?: InputMaybe<UserRole>;
  roleIn?: InputMaybe<Array<UserRole>>;
  roleNEQ?: InputMaybe<UserRole>;
  roleNotIn?: InputMaybe<Array<UserRole>>;
  /** uid field predicates */
  uid?: InputMaybe<Scalars['String']['input']>;
  uidContains?: InputMaybe<Scalars['String']['input']>;
  uidContainsFold?: InputMaybe<Scalars['String']['input']>;
  uidEqualFold?: InputMaybe<Scalars['String']['input']>;
  uidGT?: InputMaybe<Scalars['String']['input']>;
  uidGTE?: InputMaybe<Scalars['String']['input']>;
  uidHasPrefix?: InputMaybe<Scalars['String']['input']>;
  uidHasSuffix?: InputMaybe<Scalars['String']['input']>;
  uidIn?: InputMaybe<Array<Scalars['String']['input']>>;
  uidLT?: InputMaybe<Scalars['String']['input']>;
  uidLTE?: InputMaybe<Scalars['String']['input']>;
  uidNEQ?: InputMaybe<Scalars['String']['input']>;
  uidNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** username field predicates */
  username?: InputMaybe<Scalars['String']['input']>;
  usernameContains?: InputMaybe<Scalars['String']['input']>;
  usernameContainsFold?: InputMaybe<Scalars['String']['input']>;
  usernameEqualFold?: InputMaybe<Scalars['String']['input']>;
  usernameGT?: InputMaybe<Scalars['String']['input']>;
  usernameGTE?: InputMaybe<Scalars['String']['input']>;
  usernameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  usernameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  usernameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  usernameLT?: InputMaybe<Scalars['String']['input']>;
  usernameLTE?: InputMaybe<Scalars['String']['input']>;
  usernameNEQ?: InputMaybe<Scalars['String']['input']>;
  usernameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Variant = Node & {
  __typename?: 'Variant';
  attributes?: Maybe<Array<Attributes>>;
  createdAt?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  optionType: VariantOptionType;
  product?: Maybe<Product>;
  updatedAt?: Maybe<Scalars['Time']['output']>;
};

/** A connection to a list of items. */
export type VariantConnection = {
  __typename?: 'VariantConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VariantEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type VariantEdge = {
  __typename?: 'VariantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Variant>;
};

/** VariantOptionType is enum for the field option_type */
export enum VariantOptionType {
  ColorSwatch = 'Color_swatch',
  Dropdownx = 'Dropdownx',
  ImageSwatch = 'Image_swatch',
  RadioButton = 'Radio_button',
  TextBoxx = 'Text_boxx'
}

/** Ordering options for Variant connections */
export type VariantOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Variants. */
  field: VariantOrderField;
};

/** Properties by which Variant connections can be ordered. */
export enum VariantOrderField {
  CreatedAt = 'CREATED_AT',
  Name = 'NAME',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * VariantWhereInput is used for filtering Variant objects.
 * Input was generated by ent.
 */
export type VariantWhereInput = {
  and?: InputMaybe<Array<VariantWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** attributes edge predicates */
  hasAttributes?: InputMaybe<Scalars['Boolean']['input']>;
  hasAttributesWith?: InputMaybe<Array<AttributesWhereInput>>;
  /** product edge predicates */
  hasProduct?: InputMaybe<Scalars['Boolean']['input']>;
  hasProductWith?: InputMaybe<Array<ProductWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<VariantWhereInput>;
  /** option_type field predicates */
  optionType?: InputMaybe<VariantOptionType>;
  optionTypeIn?: InputMaybe<Array<VariantOptionType>>;
  optionTypeNEQ?: InputMaybe<VariantOptionType>;
  optionTypeNotIn?: InputMaybe<Array<VariantOptionType>>;
  or?: InputMaybe<Array<VariantWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CategoriesQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<CategoryOrder>;
  where?: InputMaybe<CategoryWhereInput>;
}>;


export type CategoriesQuery = { __typename?: 'Query', categories: { __typename?: 'CategoryConnection', totalCount: number, edges?: Array<{ __typename?: 'CategoryEdge', node?: { __typename?: 'Category', id: string, name: string, createdAt?: any | null, children?: Array<{ __typename?: 'Category', id: string, name: string }> | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null } } };

export type ProductsQueryVariables = Exact<{ [key: string]: never; }>;


export type ProductsQuery = { __typename?: 'Query', products: { __typename?: 'ProductConnection', edges?: Array<{ __typename?: 'ProductEdge', node?: { __typename?: 'Product', id: string, name: string, description: string, status?: boolean | null, images?: Array<string> | null, createdAt?: any | null, variants?: Array<{ __typename?: 'Variant', name: string, attributes?: Array<{ __typename?: 'Attributes', name: string, image?: string | null }> | null }> | null } | null } | null> | null } };


export const CategoriesDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"categories"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"after"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Cursor"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"before"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Cursor"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"first"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"last"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"orderBy"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"CategoryOrder"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"where"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"CategoryWhereInput"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"categories"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"after"},"value":{"kind":"Variable","name":{"kind":"Name","value":"after"}}},{"kind":"Argument","name":{"kind":"Name","value":"before"},"value":{"kind":"Variable","name":{"kind":"Name","value":"before"}}},{"kind":"Argument","name":{"kind":"Name","value":"first"},"value":{"kind":"Variable","name":{"kind":"Name","value":"first"}}},{"kind":"Argument","name":{"kind":"Name","value":"last"},"value":{"kind":"Variable","name":{"kind":"Name","value":"last"}}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"Variable","name":{"kind":"Name","value":"orderBy"}}},{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"Variable","name":{"kind":"Name","value":"where"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"totalCount"}},{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"children"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"pageInfo"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"hasNextPage"}},{"kind":"Field","name":{"kind":"Name","value":"hasPreviousPage"}},{"kind":"Field","name":{"kind":"Name","value":"startCursor"}},{"kind":"Field","name":{"kind":"Name","value":"endCursor"}}]}}]}}]}}]} as unknown as DocumentNode<CategoriesQuery, CategoriesQueryVariables>;
export const ProductsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"products"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"products"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"description"}},{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"images"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"variants"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"attributes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"image"}}]}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<ProductsQuery, ProductsQueryVariables>;